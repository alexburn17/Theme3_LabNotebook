# import numpy and check to ensure the version of python is correct for my conda env.
# import numpy and check to ensure the version of python is correct for my conda env.
import numpy as np
import platform
print(platform.python_version())
# a 150 x 2 array of random numbers bound 0 to 1
randArray = np.random.rand(150,2)
print(randArray[0:3,])
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
from numpy.polynomial.polynomial import polyfit
from numpy.polynomial.polynomial import polyfit
# assign names x and y
x = r.randArray_R["X1"]
y =r.randArray_R["X2"]
# plot the values in the dictionary
plt.scatter(x, y)
plt.xlabel('X')
plt.ylabel('Y')
plt.show()
import netCDF4 as nc
import numpy as np
# locate local path to .nc4 test file
fn = "/Users/pburnham/Documents/GitHub/Theme3_LabNotebook/R_scripts/data/prcp_1980.nc4"
# create netcdf data set
ds = nc.Dataset(fn)
# Pull precipitation data out of the netcd4 object
prcp=ds['prcp'][:]
# print a subset of the masked array
print(prcp[0, 500:505, 200:205])
# basic summary stats
print(np.max(prcp))
print(np.min(prcp))
print(np.mean(prcp))
from sqlalchemy import create_engine
from cubes.tutorial.sql import create_table_from_csv
from cubes import Workspace
#begin the sqlite environment
engine = create_engine('sqlite:///data.sqlite')
# create the table and fields
create_table_from_csv(engine,
"/Users/pburnham/Documents/GitHub/Theme3_LabNotebook/R_scripts/data/IBRD_Balance_Sheet__FY2010.csv",
table_name="ibrd_balance",
fields=[
("category", "string"),
("category_label", "string"),
("subcategory", "string"),
("subcategory_label", "string"),
("line_item", "string"),
("year", "integer"),
("amount", "integer")],
create_id=True
)
# initiate the workspace
workspace = Workspace()
workspace.register_default_store("sql", url="sqlite:///data.sqlite")
# import the model as a .json file
workspace.import_model("tutorial_model.json")
# start up the browser
browser = workspace.browser("ibrd_balance")
# use the aggregate function to get an aggregation for the whole cube
result = browser.aggregate()
# print the results for record counts and amount sum
print(result.summary["record_count"])
print(result.summary["amount_sum"])
import glob
import numpy as np
import h5py
import matplotlib.pyplot as plt
import netCDF4 as nc
import csv
import os
os.environ["PROJ_LIB"] = r'C:\Users\pburnham\Anaconda3\envs\env\Library\share (location of epsg)'
#os.environ["PROJ_LIB"] = '/opt/anaconda3/pkgs/proj4-5.2.0-h6de7cb9_1006/share/proj/epsg'
from mpl_toolkits.basemap import Basemap
direc ="/Users/pburnham/Documents/GitHub/Theme3_LabNotebook/R_scripts/data/dayLength/"
# create a list of all .nc4 files in my data folder that are day length data
dataPaths = glob.glob(direc+"dayl*.nc4")
# make sure paths look good
print(dataPaths)
# check out how they are read in (its a list of three paths)
print(type(dataPaths))
# in this case, time is the number of files as each .nc4 file is a year
time = len(dataPaths) # time dimension (three times: 1980-1982 inclusive)
# initialize a list to store files in during the loop
myDataList = [None] * time
# create list of netcdf data sets
for t in range(0, time):
myDataList[t] = nc.Dataset(dataPaths[t])
# these commands print the x and y dimensions for the data sets
#lat = len(ds.dimensions['x'])
####################################################################################################################
# base projection of a map
map = Basemap(projection='merc',llcrnrlon=-165.,llcrnrlat=0.,urcrnrlon=-50.,urcrnrlat=70.,resolution='i')
map = Basemap(projection='merc',llcrnrlon=-165.,llcrnrlat=0.,urcrnrlon=-50.,urcrnrlat=70.,resolution='i')
# add map layers/boarders
map.drawcoastlines() # draws coast lines
map.drawstates() # draws states
map.drawcountries() # draws country bourders
map.drawlsmask(land_color='Linen', ocean_color='#CCFFFF') # pick map colors
map.drawcounties() # draw county lines
# add parallels and meridians
parallels = np.arange(0,90,20.) # between 90 and 20 ever 20 degrees
parallels = np.arange(0,90,20.) # between 90 and 20 ever 20 degrees
meridians = np.arange(-180,180,20.) # between -180 and 180 every 20 degrees
# add them to the map
map.drawparallels(parallels,labels=[1,0,0,0],fontsize=10)
map.drawmeridians(meridians,labels=[0,0,0,1],fontsize=10)
plt.show()
####################################################################################################################
# plot the first object in my list of data sets (1982)
print(myDataList[0])
# exploring the values of these various dimensions
lat = myDataList[0].variables['lat'][:] # matrix of lats
lon = myDataList[0].variables['lon'][:]# matrix of longs
time = myDataList[0].variables['time'][:] # list of codes for 365 days
dayl = myDataList[0].variables['dayl'][:] # this is a list of matrices one for each day of the year
#print(dayl[364,:,:]) # prints last days worth of data for all recorded lats and longs
# base projection of a map around Hawaii where the data are focused here
map = Basemap(projection='merc',llcrnrlon=-165.,llcrnrlat=15.,urcrnrlon=-150.,urcrnrlat=25.,resolution='i')
# add map layers/boarders as before
map.drawcoastlines() # draws coast lines
map.drawstates() # draws states
map.drawcountries() # draws country bourders
map.drawlsmask(land_color='Linen', ocean_color='#CCFFFF') # pick map colors
map.drawcounties() # draw county lines
map.drawcounties() # draw county lines
# add parallels and meridians, higher granularity becasue of the cropping
parallels = np.arange(0,90,5.) # # between 90 and 20 ever 5 degrees
meridians = np.arange(-180,180,5.) # between -180 and 180 every 5 degrees
# add them to the map
# add them to the map
map.drawparallels(parallels,labels=[1,0,0,0],fontsize=10)
map.drawmeridians(meridians,labels=[0,0,0,1],fontsize=10)
#lons, lats = np.meshgrid(lonVec, latVec) Needed to expand a grid if only lat and long vecs instead of full matrix
# set coords for drawing heat map data as lat and long
# convert lat and long matrices to mapping coords
x,y = map(lon, lat)
# what is the shape of the coords
print(x.shape) # 584 by 284
# draw on the map for the 6th day of the year
dl = map.contourf(x, y, dayl[5,:,:])
# plot the color bar and add title and labels
cb = map.colorbar(dl,"right", size="5%", pad="2%")
plt.title('1982 Day Length Day 6')
cb.set_label('Day Length')
plt.show()
#load the reticulate package
library(reticulate)
# activate my previously created conda 3.7 environment
use_condaenv(condaenv = "Python37Env", conda = "auto", required = FALSE)
reticulate::repl_python()
