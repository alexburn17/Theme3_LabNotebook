---
title: "Theme 3 Lab Notebook Volume 4"
output: html_document
---

### Description:

Date created:  15 August 2021           
Author: P. Alexander Burnham

**Summary** This document follows my progress on Theme 3 in order to provide a location for me and other members of the team to keep track of this work and maintain annotated description and functioning examples of previous iterations and related vignettes. 



Load in conda env:
```{r setup, include=T}


#load the reticulate package  
library(reticulate)

# activate my previously created conda 3.7 environment
use_condaenv(condaenv = "Python37Env", conda = "auto", required = FALSE)

```

Make sure my 3.7 conda env is loaded
```{python}

import platform

# make sure python 3.7 is laoded
print(platform.python_version())
```


Here I modify the previous functions to handle multi-band geotiffs. The added functionality makes the pipeline more effective and generalizeable. I used K values in a multiband geotif and R_0 values in a single band tif as the test cases (generated by Matt). This should be a good test of the pipeline using realistic data and a realistic spatial and temporal scale. The functions and driver are below.

### Align Raster
```{python, evaluate=FALSE}

from osgeo import gdal
import glob
import numpy as np

######################################################################################################################
# DESCRIPTION: This function called raster_align takes a list of raster names, loads the rasters
# into memory and ensures they have the same aligned structure with the correct SRS codes and consitant resolutions
#
# AUTHOR: P. Alexander Burnham
# 5 August 2021
#
# INPUTS:
# rastNames (required): a list or array of file names including the required path if in another directory.
# resolution: the pixel dimensions to be used for all rasters. Defaults to the largest common pixel size
# SRS: this is the SRS code that sets the units and geospatial scale. Defaults to EPSG:3857 like google maps
# noneVal: the value to be used for pixels in the raster that contain no value. Defaults to -9999
#
# OUTPUT:
# It outputs a list of rescaled and gepspatialy aligned rasters
######################################################################################################################
def raster_align(rastNames=None, resolution=None, SRS=3857, noneVal=-9999):

    if rastNames is None:
        print("Error: No file list provided! Please pass raster_align a list of raster file names.")
        quit() # exit program and display message when no file names provided

    # define the espg code as a character for GDAL
    SRS_code = "EPSG:" + str(SRS)

    timeList = len(rastNames) # time dimension for list

    # initialize a mat to store files in during the loop and one to store the modification
    dataMat = [[0] * timeList for i in range(3)]


    # create a list of rasters in first column
    for t in range(timeList):
        dataMat[0][t] = gdal.Open(rastNames[t])

    # if resolution is not provided, default to the greatest common resolution
    if resolution is None:
        # get greatest common dimension
        for j in range(timeList):

            # put on same scale based on the SRS code to get consistant resolution values
            temp = gdal.Warp('', dataMat[0][j], dstSRS=SRS_code, format='VRT')
            dataMat[1][j] = temp.GetGeoTransform()[1]

        temp=None # flush from disk

        # get max resolution value
        resolution = np.max(dataMat[1])


    # do transformation and alignment
    for i in range(timeList):
        dataMat[2][i] = gdal.Warp('', dataMat[0][i], targetAlignedPixels=True, dstSRS=SRS_code, format='MEM',
        xRes=resolution, yRes=-resolution, dstNodata=noneVal)




    return dataMat[2]
######################################################################################################################
# END FUNCTION
######################################################################################################################
```


### Trim the raster 
```{python, evaluate=FALSE}
import re
import numpy as np
from osgeo import gdal

######################################################################################################################
# DESCRIPTION: raster_trim takes a list of rasters as trims them to the greatest common dimensions
# and writes out a list of numpy arrays. The last two elements in the list are the greatest common coords
# for the upper left and lower right corners and the GDAL geo-transform output
#
# AUTHOR: P. Alexander Burnham
# 9 August 2021
# last update: 16 August 2021
#
# INPUTS:
# rastList (required): a list of raster objects typically already rescaled by the raster_align function.
#
# OUTPUT:
# A list of trimmed raster matrices with the last two elements as a vector of the greatest common coords
# for the upper left and lower right corners and the GDAL geotransform output vector
######################################################################################################################

def raster_trim_multi(rastList=None):

    if rastList is None:
            print("Error: No raster list provided! Please pass raster_trim a list of rasters processed by raster_align.")
            quit() # exit program and display message when no file names provided


    outList = [] # initialize a list

    # create matrix for storing corner data
    cornerArray = np.empty(shape=(len(rastList),4))

    # here is where the loop needs to be:
    for i in range(len(rastList)):

##############################################################################################################

        # get meta data for each raster
        meta = gdal.Info(rastList[i])

        # use regex to extract upper and lower left corners
        Uleft = re.search(r'Upper Left  \(([^)]+)', meta).group(1)
        Lright = re.search(r'Lower Right \(([^)]+)', meta).group(1)

        # create full string
        corners = Uleft + ',' + Lright

        # numeric list of corners (upper left [0-1] and lower right [2-3])
        cornersList = corners.split(',')
        cornersList = [ float(x) for x in cornersList ]

        # add corners to an array
        cornerArray[i,:] = cornersList

########################################################################################################################

    # find greatest common dimensions to crop rasters to:
    # highest x, lowest y (upper left corner): lowest x, highest y (lower right corner)
    cornersCommon = [np.max(cornerArray[:,0]), np.min(cornerArray[:,1]), np.min(cornerArray[:,2]), np.max(cornerArray[:,3])]

    #p1 = point upper left of bounding box
    #p2 = point bottom right of bounding box
    p1 = (cornersCommon[0], cornersCommon[1])
    p2 = (cornersCommon[2], cornersCommon[3])

    # create matrix for bounding data
    tempArray = np.empty(shape=(1,4))



    # loop to find common bounding box
    for i in range(len(rastList)):

        # these need to be indexed the same way
        gt = rastList[i].GetGeoTransform()

        # get pixel sizes and the lower left of the raster
        xinit = gt[0]
        yinit = gt[3]
        xsize = gt[1]
        ysize = gt[5]

        # get row and columns
        row1 = (p1[1] - yinit)/ysize
        col1 = (p1[0] - xinit)/xsize
        row2 = (p2[1] - yinit)/ysize
        col2 = (p2[0] - xinit)/xsize

        # floating point calcs and conver to ints
        tempArray[0,:] = [col1, row1, col2 - col1, row2 - row1]
        tempInt = tempArray.astype(np.int)

        # trim the matrix
        dataLayer = rastList[i].ReadAsArray( int(tempInt[0,0]), int(tempInt[0,1]), int(tempInt[0,2]), int(tempInt[0,3]) )

        # append the data layers to the list
        outList.append(dataLayer)

        ###################################################################################################

    # add the common coords and geotransform data
    outList.append(cornersCommon)
    outList.append(gt)

    return outList


```


### Get the coords

```{python, evaluate=FALSE}
import numpy as np
from osgeo import gdal

######################################################################################################################
# DESCRIPTION: get_coords takes in a list of trimmed raster layers from raster_trim
# and returns a list of lat and long coords
#
# AUTHOR: P. Alexander Burnham
# 10 August 2021
# last update: 16 August 2021
#
# INPUTS:
# trimmedRasts (required): a list of trimmed raster arrays from raster_trim
#
# OUTPUT:
# A list with the first element as a vector of lats and the second a vector of lons
######################################################################################################################

def get_coords(trimmedRasts=None):

    if trimmedRasts is None:
            print("Error: No raster list provided! Please pass get_coords a list of rasters processed by taster_trim.")
            quit() # exit program and display message when no file names provided

    ###################################################################################################

    outList = []

    # get the necessary structures from the object
    data = trimmedRasts[0]
    gt = trimmedRasts[-1]
    cornersCommon = trimmedRasts[-2]

    # pull out pixel size
    xsize = gt[1]
    ysize = gt[5]


    # get data mat dimensions
    width = data.shape[-1]
    height = data.shape[-2]

    # get lower left corner of clipped matrix
    ylow = cornersCommon[1]
    xlow = cornersCommon[0]


    # dimensions from 0 to max dims of dataset
    my=np.arange(start=0, stop=height)
    mx=np.arange(start=0, stop=width)


    # get lats and longs
    longVec = np.multiply(mx, xsize) + xlow # longitude vector
    latVec = np.multiply(my, ysize) + ylow # latitude vector


    outList.append(latVec)
    outList.append(longVec)

    return outList

    ###################################################################################################


```


### Make the file
```{python, evaluate=FALSE}
import netCDF4 as nc
import numpy as np
from osgeo import gdal

######################################################################################################################
# DESCRIPTION: write_cube writes out a .nc file from the input of the raster_trim function and
# creates a netCDF4 dataset as a side effect
#
# AUTHOR: P. Alexander Burnham
# 11 August 2021
#
# INPUTS:
# rastList (required): a list of trimmed raster arrays from raster_trim
# yCoords: a vector for all of the y coordinates (lats)
# xCoords: a vector for all of the x coordinates (lons)
# fileName: a character string for the path and file name of the .nc file
#
# OUTPUT:
# It outputs a netCDF4 dataset and writes a .nc file to disk
######################################################################################################################

def write_cube(rastList=None, yCoords=None, xCoords=None, fileName=None, timePoints=None):

    if rastList is None:
                print("Error: No raster list provided! Please pass write_cube a list of rasters processed by raster_trim.")
                quit() # exit program and display message when no file names provided

    data = rastList[: len(rastList) ]

    ds = nc.Dataset(fileName, 'w', format='NETCDF4')

    # inmtialize vars by creating dimensions (long=X)
    time = ds.createDimension('time', timePoints) # no time var in this case
    lat = ds.createDimension('lat', len(yCoords))
    lon = ds.createDimension('lon', len(xCoords))

    # create variables in the data set
    times = ds.createVariable('time', 'f4', ('time',))
    lats = ds.createVariable('lat', 'f4', ('lat',))
    lons = ds.createVariable('lon', 'f4', ('lon',))
    value = ds.createVariable('value', 'f4', ('time', 'lat', 'lon',))
    value.units = 'My Units'


    # create the main variables
    ds.variables['value'][0:len(data)] = data
    ds.variables['lat'][:] = yCoords #add lat vals
    ds.variables['lon'][:] = xCoords # add long vals

    return ds

    ds.close() # close the dataset out in memory


```


### Tree Driver
```{python, evaluate=FALSE}

# import glob
# import re
# import numpy as np
# import matplotlib.pyplot as plt
# import netCDF4 as nc
# from rasterAlign import *
# from rasterTrim import *
# from getCoords import *
# from cuberator import *
# from trimMultiBand import *
# import time


# set my absolute directory path for where the data are
direc ="/Users/pburnham/Documents/geospatialData/Carya_ovata/"

# create a list of all raster files that end in .tif
dataPaths = glob.glob(direc+"*.tif")


# call the raster align function 4326 vs 3857 nonVal SRS resolution
alignedRasters = raster_align(rastNames=dataPaths, noneVal=-9999, resolution=None, SRS=4326)


# call the raster trim function which trims all data sets and creates list of matrices
# including the common dimensions list and the geotransform vector
trimmedRasters = raster_trim_multi(alignedRasters)


# get x and y coordinates for the aligned and trimmed rasters
# index 0 is lat and index 1 is long
rasterCoords = get_coords(trimmedRasters)


# Write out the cube
##################################################################################################

# initialize file name
fn = '/Users/pburnham/Documents/GitHub/Theme3_Burnham_Private/Theme3_PythonProjects/Python37Theme3/treeK.nc'

ds = write_cube(rastList=trimmedRasters[0], yCoords=rasterCoords[0], xCoords=rasterCoords[1], fileName=fn, timePoints=100)

val = ds.variables['value'][:]
print(val.shape) # print the values




################################################################################################################
# initialize file name
fn1 = '/Users/pburnham/Documents/GitHub/Theme3_Burnham_Private/Theme3_PythonProjects/Python37Theme3/treeN_0.nc'

ds1 = write_cube(rastList=trimmedRasters[1], yCoords=rasterCoords[0], xCoords=rasterCoords[1], fileName=fn1, timePoints=1)

val1 = ds1.variables['value'][:]
print(val1.shape) # print the values


# # plot matrix to see of they are properly aligned
# im = plt.imshow(val[2,:,:], cmap='hot', interpolation='nearest')
# plt.show()



```
